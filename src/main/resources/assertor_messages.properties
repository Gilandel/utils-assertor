# not suffix = .not
# prerequisites suffix = .pre

# OPERATORS
operator.and = \u0020AND\u0020
operator.or = \u0020OR\u0020
operator.xor = \u0020XOR\u0020
operator.nand = \u0020NAND\u0020
operator.nor = \u0020NOR\u0020

# OBJECT
object.null = the object '{0}' should be null
object.null.not = the object should NOT be null
object.equals = the object '{0}' should be equal to '{1}'
object.equals.not = the object '{0}' should NOT be equal to '{1}'
object.instance.pre = the instantiable and the type cannot be null
object.instance = the object '{0}' should be an instance of '{1}'
object.instance.not = the object '{0}' should NOT be an instance of '{1}'
object.assignable.pre = the assignable class and the type cannot be null
object.assignable = the object '{0}' should be assignable from '{1}'
object.assignable.not = the object '{0}' should NOT be assignable from '{1}'
object.hashCode = the object '{0}' should have the hash code '{1}'
object.hashCode.not = the object '{0}' should NOT have the hash code '{1}'
object.validates.pre = the predicate cannot be null
object.validates = the object '{0}' should validate the predicate
object.validates.not = the object '{0}' should invalidate the predicate

# BOOLEAN
boolean.true = the boolean should be true
boolean.true.not = the boolean should be false
boolean.false = the boolean should be false
boolean.false.not = the boolean should be true

# CLASS
class.assignable.pre = neither classes can be null
class.assignable = the class '{0}' should be assignable from '{1}'
class.assignable.not = the class '{0}' should NOT be assignable from '{1}'
class.name.pre = the classes cannot be null and the name cannot be null or empty
class.name = the class '{0}' should have the name '{1}'
class.name.not = the class '{0}' should NOT have the name '{1}'
class.simpleName.pre = the classes cannot be null and the simple name cannot be null or empty
class.simpleName = the class '{0}' should have the simple name '{1}'
class.simpleName.not = the class '{0}' should NOT have the simple name '{1}'
class.canonicalName.pre = the classes cannot be null and the canonical name cannot be null or empty
class.canonicalName = the class '{0}' should have the canonical name '{1}'
class.canonicalName.not = the class '{0}' should NOT have the canonical name '{1}'
class.typeName.pre = the classes cannot be null and the type name cannot be null or empty
class.typeName = the class '{0}' should have the type name '{1}'
class.typeName.not = the class '{0}' should NOT have the type name '{1}'
class.packageName.pre = the classes cannot be null and the package name cannot be null or empty
class.packageName = the class '{0}' should have the package name '{1}'
class.packageName.not = the class '{0}' should NOT have the package name '{1}'

# ENUMERATION
enum.name.pre = the enumeration cannot be null and the name cannot be null or empty
enum.name = the enumeration's name '{0}' should be equal to '{1}'
enum.name.not = the enumeration's name '{0}' should NOT be equal to '{1}'
enum.ordinal.pre = the enumeration cannot be null and the ordinal has to be greater than or equal to 0
enum.ordinal = the enumeration's ordinal '{0}' should be equal to '{1}'
enum.ordinal.not = the enumeration's ordinal '{0}' should NOT be equal to '{1}'

# NUMBER
number.equals = the number '{0}' should be equal to '{1}'
number.equals.not = the number '{0}' should NOT be equal to '{1}'
number.zero = the number '{0}' should be equal to 0
number.zero.not = the number '{0}' should be NOT equal to 0
number.positive = the number '{0}' should be positive
number.positive.not = the number '{0}' should be negative or equal to zero
number.negative = the number '{0}' should be negative
number.negative.not = the number '{0}' should be positive or equal to zero
number.gt = the number '{0}' should be greater than '{1}'
number.gt.not = the number '{0}' should be lower than or equal to '{1}'
number.gte = the number '{0}' should be greater than or equal to '{1}'
number.gte.not = the number '{0}' should be lower than '{1}'
number.lt = the number '{0}' should be lower than '{1}'
number.lt.not = the number '{0}' should be greater than or equal to '{1}'
number.lte = the number '{0}' should be lower than or equal to '{1}'
number.lte.not = the number '{0}' should be greater than '{1}'

# CHAR SEQUENCE
csq.length.pre = the length has to be greater than or equal to 0 and the char sequence cannot be null
csq.length = the char sequence '{0}' should have the following length: {1}
csq.length.not = the char sequence '{0}' should NOT have the following length: {1}
csq.empty = the char sequence '{0}' should be null or empty
csq.empty.not = the char sequence should be NOT empty and NOT null
csq.blank = the char sequence '{0}' should be null, empty or blank
csq.blank.not = the char sequence should be NOT null, NOT empty and NOT blank
csq.equals = the char sequence '{0}' should be equal to '{1}'
csq.equals.not = the char sequence '{0}' should NOT be equal to '{1}'
csq.contains.pre = the char sequence cannot be null and the searched substring cannot be null or empty
csq.contains = the char sequence '{0}' should contain '{1}'
csq.contains.not = the char sequence '{0}' should NOT contain '{1}'
csq.starts.pre = the char sequence cannot be null and the searched substring cannot be null or empty
csq.starts = the char sequence '{0}' should start with '{1}'
csq.starts.not = the char sequence '{0}' should NOT start with '{1}'
csq.ends.pre = the char sequence cannot be null and the searched substring cannot be null or empty
csq.ends = the char sequence '{0}' should end with '{1}'
csq.ends.not = the char sequence '{0}' should NOT end with '{1}'
csq.matches.pre = the char sequence and the regular expression cannot be null
csq.matches = the char sequence '{0}' should match the regular expression: {1}
csq.matches.not = the char sequence '{0}' should NOT match the regular expression: {1}
csq.find.pre = the char sequence and the regular expression cannot be null
csq.find = the char sequence '{0}' should contain matching sequence(s) of the regular expression: {1}
csq.find.not = the char sequence '{0}' should NOT contain matching sequence(s) of the regular expression: {1}

# DATE / CALENDAR
date.equals.pre = neither dates can be null
date.equals = the date '{0}' should be equal to '{1}'
date.equals.not = the date '{0}' should be NOT equal to '{1}'
date.around.pre = neither dates can be null, calendar field has to be a supported value and calendar amount different to 0
date.around = the date '{0}' should be around to '{1}' by {3} {2}
date.around.not = the date '{0}' should be NOT around to '{1}' by {3} {2}
date.after.pre = neither dates can be null
date.after = the date '{0}' should be after '{1}'
date.after.not = the date '{0}' should be before or equal to '{1}'
date.afterOrEqual.pre = neither dates can be null
date.afterOrEqual = the date '{0}' should be after or equal to '{1}'
date.afterOrEqual.not = the date '{0}' should be before '{1}'
date.before.pre = neither dates can be null
date.before = the date '{0}' should be before '{1}'
date.before.not = the date '{0}' should be after or equal to '{1}'
date.beforeOrEqual.pre = neither dates can be null
date.beforeOrEqual = the date '{0}' should be before or equal to '{1}'
date.beforeOrEqual.not = the date '{0}' should be after '{1}'

# TEMPORAL
temporal.equals.pre = neither temporal can be null
temporal.equals = the temporal '{0}' should be equal to '{1}'
temporal.equals.not = the temporal '{0}' should be NOT equal to '{1}'
temporal.around.pre = neither temporal can be null
temporal.around = the temporal '{0}' should be around to '{1}' by {3} {2}
temporal.around.not = the temporal '{0}' should be NOT around to '{1}' by {3} {2}
temporal.after.pre = neither temporal can be null
temporal.after = the temporal '{0}' should be after '{1}'
temporal.after.not = the temporal '{0}' should be before or equal to '{1}'
temporal.afterOrEqual.pre = neither temporal can be null
temporal.afterOrEqual = the temporal '{0}' should be after or equal to '{1}'
temporal.afterOrEqual.not = the temporal '{0}' should be before '{1}'
temporal.before.pre = neither temporal can be null
temporal.before = the temporal '{0}' should be before '{1}'
temporal.before.not = the temporal '{0}' should be after or equal to '{1}'
temporal.beforeOrEqual.pre = neither temporal can be null
temporal.beforeOrEqual = the temporal '{0}' should be before or equal to '{1}'
temporal.beforeOrEqual.not = the temporal '{0}' should be after '{1}'

# ARRAY
array.length.pre = the length has to be greater than or equal to 0 and the array cannot be null
array.length = the array '{0}' should have the following length: {1}
array.length.not = the array '{0}' should NOT have the following length: {1}
array.empty = the array '{0}' should be empty or null
array.empty.not = the array should be NOT empty and NOT null
array.contains.object.pre = the array cannot be null
array.contains.object = the array '{0}' should contain the object '{1}'
array.contains.object.not = the array '{0}' should NOT contain the object '{1}'
array.contains.array.all.pre = neither arrays can be null
array.contains.array.all = the array '{0}' should contain all the value of '{1}'
array.contains.array.all.not = the array '{0}' should NOT contain any the value of '{1}'
array.contains.array.any.pre = neither arrays can be null
array.contains.array.any = the array '{0}' should contain any the value of '{1}'
array.contains.array.any.not = the array '{0}' should NOT contain all the value of '{1}'

# ITERABLE
iterable.size.pre = the size has to be greater than or equal to 0 and the iterable cannot be null
iterable.size = the iterable '{0}' should have the following size: {1}
iterable.size.not = the iterable '{0}' should NOT have the following size: {1}
iterable.empty = the iterable '{0}' should be empty or null
iterable.empty.not = the iterable 'should be NOT empty and NOT null
iterable.contains.object.pre = the iterable cannot be null
iterable.contains.object = the iterable '{0}' should contain the object '{1}'
iterable.contains.object.not = the iterable '{0}' should NOT contain the object '{1}'
iterable.contains.iterable.all.pre = neither iterables can be null
iterable.contains.iterable.all = the iterable '{0}' should contain all the value of '{1}'
iterable.contains.iterable.all.not = the iterable '{0}' should NOT contain any the value of '{1}'
iterable.contains.iterable.any.pre = neither iterables can be null
iterable.contains.iterable.any = the iterable '{0}' should contain any the value of '{1}'
iterable.contains.iterable.any.not = the iterable '{0}' should NOT contain all the value of '{1}'

# MAP
map.size.pre = the size has to be greater than or equal to 0 and the map cannot be null
map.size = the map '{0}' should have the following size: {1}
map.size.not = the map '{0}' should NOT have the following size: {1}
map.empty = the map '{0}' should be empty or null
map.empty.not = the map should be NOT empty and NOT null
map.contains.key.pre = the map cannot be null or empty
map.contains.key = the map '{0}' should contain the key '{1}'
map.contains.key.not = the map '{0}' should NOT contain the key '{1}'
map.contains.pair.pre = the map cannot be null or empty
map.contains.pair = the map '{0}' should contain the key/value pair: '{1}', '{2}'
map.contains.pair.not = the map '{0}' should NOT contain the key/value pair: '{1}', '{2}'
map.contains.keys.all.pre = the map and the keys' list cannot be null or empty
map.contains.keys.all = the map '{0}' should contain all keys '{1}'
map.contains.keys.all.not = the map '{0}' should NOT contain any keys '{1}'
map.contains.keys.any.pre = the map and the keys' list cannot be null or empty
map.contains.keys.any = the map '{0}' should contain any keys '{1}'
map.contains.keys.any.not = the map '{0}' should NOT contain all keys '{1}'
map.contains.map.all.pre = neither maps can be null or empty
map.contains.map.all = the map '{0}' should contain all entries from second map '{1}'
map.contains.map.all.not = the map '{0}' should NOT contain any entries from second map '{1}'
map.contains.map.any.pre = neither maps can be null or empty
map.contains.map.any = the map '{0}' should contain any entries from second map '{1}'
map.contains.map.any.not = the map '{0}' should NOT contain all entries from second map '{1}'

# THROWABLE
throwable.instance.pre = the throwable instance, the type and the exception message cannot be null
throwable.instance = the throwable '{0}' should be an instance of '{1}' and have the expected message '{2}'
throwable.instance.not = the throwable '{0}' should NOT be an instance of '{1}' and have the expected message '{2}'
throwable.instance.pattern.pre = the throwable instance, the type and the pattern cannot be null
throwable.instance.pattern = the throwable '{0}' should be an instance of '{1}' and matches the pattern '{2}'
throwable.instance.pattern.not = the throwable '{0}' should NOT be an instance of '{1}' or matches the pattern '{2}'
throwable.assignable.pre = the throwable instance, the type and the exception message cannot be null
throwable.assignable = the throwable '{0}' should be assignable from '{1}' and have the expected message '{2}'
throwable.assignable.not = the throwable '{0}' should NOT be assignable from '{1}' and have the expected message '{2}'
throwable.assignable.pattern.pre = the throwable instance, the type and the pattern cannot be null
throwable.assignable.pattern = the throwable '{0}' should be assignable from '{1}' and match the pattern '{2}'
throwable.assignable.pattern.not = the throwable '{0}' should NOT be assignable from '{1}' and match the pattern '{2}'
throwable.cause = the throwable should have a cause
throwable.cause.not = the throwable should NOT have a cause
throwable.cause.instance.pre = the throwable and the cause type cannot be null
throwable.cause.instance = the throwable '{0}' should have a cause with an instance of '{1}'
throwable.cause.instance.not = the throwable '{0}' should NOT have a cause with an instance of '{1}'
throwable.cause.instance.message.pre = the throwable, the cause type and the exception message cannot be null
throwable.cause.instance.message = the throwable '{0}' should have a cause with an instance of '{1}' and have the expected message '{2}'
throwable.cause.instance.message.not = the throwable '{0}' should NOT have a cause with an instance of '{1}' and have the expected message '{2}'
throwable.cause.instance.pattern.pre = the throwable, the cause type and the pattern cannot be null
throwable.cause.instance.pattern = the throwable '{0}' should have a cause with an instance of '{1}' and match the pattern '{2}'
throwable.cause.instance.pattern.not = the throwable '{0}' should NOT have a cause with an instance of '{1}' and match the pattern '{2}'
throwable.cause.assignable.pre = the throwable and the cause type cannot be null
throwable.cause.assignable = the throwable '{0}' should have a cause assignable from '{1}'
throwable.cause.assignable.not = the throwable '{0}' should NOT have a cause assignable from '{1}'
throwable.cause.assignable.message.pre = the throwable, the cause type and the exception message cannot be null
throwable.cause.assignable.message = the throwable '{0}' should have a cause assignable from '{1}' and have the expected message '{2}'
throwable.cause.assignable.message.not = the throwable '{0}' should NOT have a cause assignable from '{1}' and have the expected message '{2}'
throwable.cause.assignable.pattern.pre = the throwable, the cause type and the pattern cannot be null
throwable.cause.assignable.pattern = the throwable '{0}' should have a cause assignable from '{1}' and match the pattern '{2}'
throwable.cause.assignable.pattern.not = the throwable '{0}' should NOT have a cause assignable from '{1}' and match the pattern '{2}'